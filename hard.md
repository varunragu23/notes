## Hard (91) ** 0. [Count of Smaller Number before itself.java] (https://github.com/awangdev/LintCode/blob/master/Java/Count%20of%20Smaller%20Number%20before%20itself.java) ** Level : Hard Tags: []        Very similar to Count of Smaller Number. The actual value is used to form the segment tree, and the leaf is stored (count of smaller number). Trick: Query first, then modify. Each time Query, A [i] has not been added to the Segment Tree, and A [i + 1, ... etc] has not been added yet. Then naturally it is coutning smaller number before itself. Tricky! Also note: In modify: Check root.start <= index and index <= root.end. It was ignored in the past. You can also write this later. (In fact, it is Make sense, which is to more strictly check the index and the position in root.left or root.right) --- ** 1. [Kth Smallest Sum In Two Sorted Arrays.java] (https://github.com/awangdev/LintCode/blob/master/Java/Kth%20Smallest%20Sum%20In%20Two%20Sorted%20Arrays.java) ** Level: Hard Tags: []        Use priority queue. Each time the smallest expansion, shift. X + 1, or y + 1: Because x and y are the smallest in Min at the moment. So the next smallest is either (x + 1, y), or (x, y + 1). Just poll () one every time, just put 2 new candidates in. Note that this approach will be repeated, for example the example (7,4) will appear twice. Block it with a HashSet. Note that the uniqueness of HashSet can be solved by using an "x, y" string. --- ** 2. [LFU Cache.java] (https://github.com/awangdev/LintCode/blob/master/Java/LFU%20Cache.java) ** Level: Hard Tags: [Design, Hash Table]        #### Hash Table -See thoughts specifically, use map in several different ways -`regular object map`: map of <key, item>, where` item: (int val; int count) ` -Use a Map <frequency count, doubly-linked node> to track the frequency -Track constant capacity, and minimum frequency -Every get (): update all frequency map as well -Every put (): update all frequency map as well, with optional removal (if over capacity) -Original post: http://www.cnblogs.com/grandyang/p/6258459.html -TODO: one doubly linked list might be good enough to replace below: -`frequency list map`: map of <frequency count, List <item >>, where the list preserves` recency` -`item location in frequency map`: map of <key, int location index in list>: -index relative to the item in a particular list, not tracking which list here --- ** 3. [Prefix and Suffix Search.java] (https://github.com/awangdev/LintCode/blob/master/Java/Prefix%20and%20Suffix%20Search.java) ** Level: Hard Tags: [Trie ]        --- ** 4. [Remove Node in Binary Search Tree.java] (https://github.com/awangdev/LintCode/blob/master/Java/Remove%20Node%20in%20Binary%20Search%20Tree.java) ** Level : Hard Tags: [BST]        Method 1: Brutle a little. Find the target and target's parent. When removing the target, rearrange the child nodes of the target into a new BST: inorder traversal, build tree based on inorder traversal list. Method 2: Analyze the rules, first find the target and parent, and then move the children nodes when the target is removed according to the nature, to ensure that it is still BST. --- ** 5. [Subarray Sum II.java] (https://github.com/awangdev/LintCode/blob/master/Java/Subarray%20Sum%20II.java) ** Level: Hard Tags: [Array, Binary Search , Two Pointers]        --- ** 6. [K Sum.java] (https://github.com/awangdev/LintCode/blob/master/Java/k%20Sum.java) ** Level: Hard Tags: [DP]        DP. How the formula comes to mind needs to be re-understood. dp [i] [j] [m]: # of possibilities such that from j elements, pick m elements and sum up to i. i: [0 ~ target] dp [i] [j] [m] = dp [i] [j-1] [m] + dp [i-A [j-1]] [j-1] [m-1]             (i not included) (i included) --- ** 7. [Copy Books.java] (https://github.com/awangdev/LintCode/blob/master/Java/Copy%20Books.java) ** Level: Hard Tags: [Binary Search, DP, Partition DP ]        Give a list of books pages [i], k people, pages [i] represents the number of pages in each book. K people start to copy at the same time from different points. Q. When can I copy it as soon as possible? #### Partition DP -The first step is to understand the problem required by the title: the first k individuals copy n books and find the least amount of time; it can also be translated into: `n books, let k individuals copy, that is, split into k segments`. -Finally, dp [n] [k] is required. On: int [n + 1] [k + 1]. -Principle: -1. Consider the last step: In [0 ~ n-1] book, the last person can choose to copy 1 book, 2 books ...... n books, the results of each cutting method are different -2. Discuss the situation of the kth person, looping at j = [0 ~ i]. And the slowest case when looping j determines the result of the kth person (barrel principle): `Math.max (dp [j] [ k-1], sum) `. -3. Among them: `dp [j] [k-1]` is the result of [k-1] individual reading the j book, which is also known as the `previous step`. The loop considers that the kth person is different j kind of previous step :) -4. The result of the loop is that dp [i] [k] = Math.min (Math.max (dp [j] [k-1], sum [j, i]), loop over i, k, j = [i ~ 0]) -Time: O (kn ^ 2), space O (nk) ##### Init -Init: dp [0] [0] = 0, 0 people 0 books -Use of Integer.MAX_VALUE: -When i = 1, k = 1, Expression: dp [i] [k] = Math.min (dp [i] [k], Math.max (dp [j] [k-1], sum)) ; -There is only one case that works: i = 0, k = 0, exactly 0 people copy 0 book, dp [0] [0] = 0. -In other cases, i = 1, k = 0, 0 people read 1 book, it cannot happen: so use Integer.MAX_VALUE to break Math.max, and maintain ridiculous values. -When the case of i = 0, k = 0 is discussed, the above equation will be calculated according to the actual situation dp [i] [k] -The init of this question is very important and tricky ##### Calculation order -k people, need a for loop; -k people, starting from copy1 book, 2, 3, ... n-1, so i = [1, n], requires a second for loop -On each i, the cutting method can be [0 ~ i], we have to calculate each worst time ##### Scrolling array -[k] only relevant to [k-1] -Space: O (n) #### Binary Search -Based on: How much time does each person spend doing binary search: How long does it take each person to complete it in K people with the least amount of time? -The range of time variable is not index or page size. It is [minPage, pageSum] -Pay attention to 3 cases when validating: people are enough k> = 0, people are not enough so the end is reduced to k <0, and there is a time (the time spent by each person) is less than the current page, return -1 -O (nLogM). N = pages.length; m = sum of pages. --- ** 8. [Scramble String.java] (https://github.com/awangdev/LintCode/blob/master/Java/Scramble%20String.java) ** Level: Hard Tags: [DP, Interval DP, String]        -Give two strings S, T. Check if they are scramble string. -scramble string definition: string can be split into binary tree form, that is, cut into substring; -After rotating a node that is not a leaf, a new substring is formed, which is the scramble of the original string. #### Interval DP Interval -Dimension reduction strike, split, dp by length. -dp [i] [j] [k]: array S starts at index i, T starts at index j, is a substring of length k, is it a scramble string ##### Break down -After two halves of everything, look at two cases:, or not rotate the two halves. For these substrings, verify whether they are scrambled. -Two halves without rotation: S [part1] corresponds to T [part1] && S [part2] corresponds to T [part2]. -rotate the two halves of division: S [part1] corresponds to T [part2] && S [part2] corresponds to T [part1]. ##### Initialization -When len == 1, it can't be rotated, that is, to see if the corresponding indexes of S and T are equal. -Initialization is very important. It ’s amazing. This initailization lays the foundation for DP, and the result is calculated with a mathematical expression. -input s1, s2 are hardly used in the main content of the entire problem, but only used in the initialization. -More details, see answer --- ** 9. [Interleaving String.java] (https://github.com/awangdev/LintCode/blob/master/Java/Interleaving%20String.java) ** Level: Hard Tags: [DP, String]        Double-sequence DP, consider from the last point. At the end of the split problem, consider the association with s1, s2 subsequence. Seeking existence, boolean --- ** 10. [Edit Distance.java] (https://github.com/awangdev/LintCode/blob/master/Java/Edit%20Distance.java) ** Level: Hard Tags: [DP, Double Sequence DP, Sequence DP, String]        time: O (MN) Space: O (N) Two strings, A to B, can insert / delete / replace, find the smallest change operation count #### Double Sequence -Consider index s [i], t [j] at the end of two strings: If you need to make these two characters the same, you might use the three operations given in the title: insert / delete / replace? -Calculate worst case first, 3 operation count + 1; then compare match case. -Note that when i or j is 0, the steps that become another number can only be fully changed. -First step, space time is O (MN), O (MN) -Rolling array optimization, space O (N) ##### Detail analysis -insert: assume insert on s, `#ofOperation = (s [0 ~ i] to t [0 ~ j-1]) + 1;` -delete: assume delete on t, `#ofOperatoin = (s [0 ~ i-1] to t [0 ~ j]) + 1;` -replace: replace both s and t, `#ofOperatoin = (s [0 ~ i-1] to t [0 ~ j-1]) + 1;` -dp [i] [j] represents the nature of the two sequences: s [0 ~ i] The minimum operation count required to convert to s [0 ~ j] -init: When i == 0, dp [0] [j] = j; + j characters each time; Similarly, when j == 0, dp [i] [0] = i; -And dp [i] [j] has two cases: `s [i] == t [j]` or `s [i]! = T [j]` ##### When to initialize -This judgment depends on experience: if you know that initialization can be done together in double for loop, then you can keep doing that -This belongs to `what is needed, initialize what` -When doing space optimization afterwards, you can easily do rolling array on 1st dimension #### Search -It can be done, but it is not recommended: this question needs to find min count, not search / find all solutions, so search will be more complicated, killing chickens. --- ** 11. [Distinct Subsequences.java] (https://github.com/awangdev/LintCode/blob/master/Java/Distinct%20Subsequences.java) ** Level: Hard Tags: [DP, String]        Double Sequence DP: 0. DP size (n + 1): find the result of the previous nth, then the dp array needs to open n + 1, because the end needs to return dp [n] [m] 1. Initialize dp [0] [j] dp [i] [0] in the for loop 2. Rolling array is optimized to O (N): If dp [i] [j] is in the for loop, it is a good replacement for curr / prev --- ** 12. [Ones and Zeroes.java] (https://github.com/awangdev/LintCode/blob/master/Java/Ones%20and%20Zeroes.java) ** Level: Hard Tags: [DP]        Still Double Sequence, but consider the third state: the amount of string array given. So opened a 3-dimensional array. If you use a scrolling array to optimize space, you need to put the for loop that you want to scroll to the outermost, not the innermost. Of course, this third definition is not a big problem in dp [] [] []. Also, pay attention to calcualte zeros and ones outside, saving time and complexity. --- ** 13. [Word Break II.java] (https://github.com/awangdev/LintCode/blob/master/Java/Word%20Break%20II.java) ** Level: Hard Tags: [Backtracking, DFS, DP, Hash Table, Memoization]        Find all word break variations, given dictionary Use memoization: `Map <prefix, List <suffix variations >>` #### DFS + Memoization -Realize the input s expands into a tree of possible prefixes. -We can do top-> bottom (add candidate + backtracking) OR bottom-> top (find list of candidates from subproblem, and cross-match) -DFS on string: find a valid word, dfs on the suffix. [NO backtraking in the solution] -DFS returns List <String>: every for loop takes a prefix substring, and append with all suffix (result of dfs) -IMPORANT: Memoization: `Map <prefix, List <suffix variations >>`, which reduces repeated calculation if the substring has been tried. -Time O (n!). Worst case, permutation of unique letters: `s = 'abcdef ....'`, and `dict = [a, b, c, d, e, f ...]` #### Regular DPs -Two DPs are used together to solve the problem of timeout: when a invalid case 'aaaaaaaaa' occurs, isValid [] stops dfs from occuring -1. Isword [i] [j], subString (i, j) exist in dict? -2. Use isWord to speed up isValid [i]: Can [i ~ end] find a reasonable solution from dict? -View i from the end: Because we need to test isWord [i] [j], j> i, and we observe the interval [i, j]; -The part of j> i also needs to be considered, we also need to know isValid [0 ～ j + 1]. So isValid [x] is a DP indicating whether [x, end] is valid this time. -i is from the end to 0, probably because it is considered that isWord [i] [j] is within [0 ~ n], so the numbers are reversed and the coordinates are easier to figure out. -(Looking back at Word Break I, there is also a practice of coordinate inversion) -3. dfs uses isValid and isWord for ordinary DFS. #### Timeout Note -Regarding regular solution: Without memoization or dp, 'aaaaa .... aaa' will repeatedly calculate the same substring -Regarding double DP solution: Set.contains (...) is used in Word Break, i is 0 from isValid. However, contains () itself is O (n); [j], judge whether i ~ j exists in dictionary based on O (1) --- ** 14. [Minimum Window Substring.java] (https://github.com/awangdev/LintCode/blob/master/Java/Minimum%20Window%20Substring.java) ** Level: Hard Tags: [Hash Table, String , Two Pointers]        Basic idea: use a char [] to store the frequency of the string. Then 2pointer, end go to the end, and continue to validate. If it meets the process as result candidate. HashMap is a bit more complicated to write than char [], but more generic --- ** 15. [Longest Substring with At Most K Distinct Characters.java] (https://github.com/awangdev/LintCode/blob/master/Java/Longest%20Substring%20with%20At%20Most%20K%20Distinct%20Characters .java) ** Level: Hard Tags: [Hash Table, Sliding Window, String]        Large cleaning O (nk) Once map.size> k, erase the char at the beginning of the longest string (marked by pointer: start) Once a char is to be cleared, the char between 1st and last appearance of this char must be cleaned from map --- ** 16. [Find Minimum in Rotated Sorted Array II.java] (https://github.com/awangdev/LintCode/blob/master/Java/Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II.java) ** Level: Hard Tags: [Array, Binary Search]        A topic that requires rigorous thinking. Because duplicates cause constant translation, the time complexity is ultimately O (n) So it is better to scan it directly and give the answer. But still write a Binary Search, but the worst result is O (n) --- ** 17. [Number of Islands II.java] (https://github.com/awangdev/LintCode/blob/master/Java/Number%20of%20Islands%20II.java) ** Level: Hard Tags: [Union Find]        Give an island grid [] [], and list of operations to fill a particualr (x, y) position. count # of remaining island after each operation. #### Union Find, model with int [] -After converting the board into a 1D array, you can use union-find to determine it. -Use int [] father's unionFind, need to convert 2D position into 1D index. This is relatively clean -When judging, one step is taken in each of the four directions to determine whether it is the same Land. -Each time the operator walks, it will count ++. If it is found to be the same island, count-- -The count addition and subtraction are all placed in UnionFind's own function, which is convenient for tracking. Just give a few helper functions. -Time: O (k * log (mn)) #### Union Find, model with Hashmap -Union-find with HashMap. #### Note: -Proof of UnionFind log (n) time: https://en.wikipedia.org/wiki/Proof_of_O(log*n)_time_complexity_of_union%E2%80%93find --- ** 18. [Word Search II.java] (https://github.com/awangdev/LintCode/blob/master/Java/Word%20Search%20II.java) ** Level: Hard Tags: [Backtracking, DFS, Trie]        Give a string of words, and a 2D character matrix. Find all the words that can be formed. Condition: 2D matrix can only be positioned next to each other. #### Trie, DFS -Compared with the previous implementation, there are some places that can be optimized: -1. During Backtracking, you can mark on board [] [] instead of opening a visited [] [] -2. You don't need to implement all the equations of the trie, you don't need it: only insert is needed here. -Common trie questions will let you search for a word, but here is a board, see if each letter of the board can come out of a word. -That is: the search here is written by hand, not the traditional trie search () funcombination -3. When there is an end in the TrieNode, the string word is stored, which means the end. When the word = null is used up, the problem of repeated search is just truncated. ##### About Trie -Build Trie with target words: insert, search, startWith. Sometimes, just: `buildTree (words)` and return root. -Still do DFS on the board matrix. -no for loop on words. Directly to board DFS: -Each layer will have an up-to-this-point string. Check if it exists in the Trie. Use this to judge. -If it does not exist, you do not need to continue DFS. -Trie solution time complexity, much better: -build Trie: n * wordMaxLength -search: boardWidth * boardHeight * (4 ^ wordMaxLength + wordMaxLength [Trie Search]) #### Regular DFS -for loop on words: inside, do board DFS based on each word. -Time cpmplexity: word []. Length * boardWidth * boardHeight * (4 ^ wordMaxLength) #### Previous Notes -Big improvement: use boolean visited on TrieNode! -Don't use rst.contains (...), because this is O (n) and timeout in leetcode (lintcode can pass) -In the Trie search () method, mark any visits. --- ** 19. [Word Squares.java] (https://github.com/awangdev/LintCode/blob/master/Java/Word%20Squares.java) ** Level: Hard Tags: [Backtracking, Trie]        Can open Trie class, which uses TrieNode. Open Trie (words) can be directly initalized with for loop A TrieNode can have a List <String> startWith: record all strings that can reach this point: a bit like a tree, ancestor-shaped storage. God operates: According to the nature of square, if list of words is selected, set int prefixIndex = list.size (). Take all the words [prefixedIndex] in the list and add them together to form the prefix of the next word candidate. Image a bit: list = ["ball", "area"]; prefixIndex = list.size (); ball [prefixIndex] = 'l'; area [prefixIndex] = 'e'; // then candidatePrefix = ball [prefixIndex] + area [prefixIndex] = "le"; Here you can use the findByPrefix function of Trie. At each point, there are all the dates that can be generated by this point. At this point, try all candidate: dfs I can think of this inverted structure to store prefix candidates in Trie, this idea is very worth thinking about. --- ** 20. [Trapping Rain Water.java] (https://github.com/awangdev/LintCode/blob/master/Java/Trapping%20Rain%20Water.java) ** Level: Hard Tags: [Array, Stack, Two Pointers]        There are many ways to solve this problem. #### method 1 Array, maintaining a left-hand highest wall array, and a right-hand highest strength array. For each index, the maximum water column that can be stored vertically is determined by the left and right highest walls: min (leftHighestWall, rightHighestWall)-currHeight. #### Method 2 The optimization above method 1, two pointers, still find the highest left and highest right. O (1) space. The idea used in method 3 is the same: the entire structure is divided by the highest bar in the middle: The left is calculated as maxLeft, and the right is calculated as maxRight. #### Method 3 2 Pointers, double-sided pinch: 1. Find the index of the highest bar in the middle 2. Swipe to the center on both sides: add (topBarIndex-currIndex) * (elevation from previous index) each time. That is, add one horizontal bar at a time. 3. Every time you want to subtract the height of the block itself #### Method 4 The main idea is the same as Method 3: On the basis of the downhill slope, the bottom has been stacked with stacks. Before finally encountering the ascent, at this time the bottom can be used to compare with all the downhill indexes accumulated before the stack, which is the water that is different from their height. The idea of ​​using a stack to record downhill, and then dig to the end with a while loop is great. --- ** 21. [Largest Rectangle in Histogram.java] (https://github.com/awangdev/LintCode/blob/master/Java/Largest%20Rectangle%20in%20Histogram.java) ** Level: Hard Tags: [Array , Monotonous Stack, Stack]        Give n bars to form a histogram. Find the rectangle with the largest area that can be found in this row of histograms. Thinking: Finding the area of ​​a rectangle is nothing more than finding two indices, then the length of the bottom edge * height. #### Monotonous Stack -The main point is to maintain a monotonically increasing stack according to the nature of the rectangle in the Histogram. -When loop over indexes: -If the height is> = previous peek (), then for that peek, it means, go down, keep going higher, the previous peek can always continue to bottom -When can't I buy a bottom? When is there a downward trend? -At this time, not all previous peeks are calculated, but all previous peeks larger than the current height are considered. -Find all the rectangles from the peek to the current height: stack.pop () -In the process of stack.pop (), the current height is not counted, because it needs to be retained in the next round, and the current index is added to the stack. -Why use stack? Because you need to know the continuously increasing peek, stack.peek () O (1), easy to use   In fact, instead of stack, you can record all heights in other ways, but it is inconvenient to find peek by O (n) #### Knowledge -Understand how monotonous stack is maintained -Maintaining a monotonous stack is required for the problem, not the nature of the stack itself.It is a clever use of stack.peek () O (1). --- ** 22. [Find Peak Element II.java] (https://github.com/awangdev/LintCode/blob/master/Java/Find%20Peak%20Element%20II.java) ** Level: Hard Tags: [Binary Search, DFS, Divide and Conquer]        2Dmatrix, the value inside has some increasing and decreasing characteristics (the details are longer, see the original question). The goal is to find the peak element peak: greater than the point value in the surrounding 4 directions #### DFS ##### Fundamental -We cannot accurately locate (x, y) at one go, but we can find the peak of the 1D array in another row / col. -Based on this point, move in the remaining two directions -1. In the middle line i = midX, find y where peak is. -2. In the middle column j = midY, find the x where the peak is. (It is possible to find the y before the strong override, that is, give up the peak of that line and find the peak on midY) -3. According to the 4 neighbor check (x, y) of (x, y) whether peak (x, y) is, if not, move it one block like a higher position -4. According to the previously calculated midX and midY, the board is divided into 4 quadrants. -This question LintCode did not do it, so the idea is correct, but the answer has not been verified again. ##### Pruning / splitting quadrant -Just find a peak in row / col every time! -Finding this point is equivalent to cutting the board in half. -Then, compared with the remaining two adjacent positions, I know where the bigger one is, and where to find the peak, that is, I cut the second knife again. -When cutting the second knife, also move (x, y) to the quadrant to be taken. DFS -Cut according to mid row: -http://www.jiuzhang.com/solution/find-peak-element-ii/#tag-highlight-lang-java -http://courses.csail.mit.edu/6.006/spring11/lectures/lec02.pdf ##### time complexity -Each level is halved -T (n) = n + T (n / 2) = n + n / 2 + n / 4 + ... + 1 = n (1 + 1/2 + .... + 1 / n) = 2n = O (n) #### Binary Search -TODO -O (nLogN) --- ** 23. [Palindrome Pairs.java] (https://github.com/awangdev/LintCode/blob/master/Java/Palindrome%20Pairs.java) ** Level: Hard Tags: [Hash Table, String, Trie]        Obvious's method is to try it all, and judge, it becomes O (n ^ 2) * O (m) = O (mn ^ 2). O (m): isPalindrome () time. Of course not, then it depends on O (nlogN), or O (n)? #### Method 1: Properties of Hash Table + Palindrome. Compound. O (mn) ##### Ideas -Each word can be split into front + mid + end. If this word + other words can form palindrome, that is to say -Chop off (mid + end), front.reverse () should exist in words []. -Cut off (front + mid), end.reverse () should be in words []. -We use HashMap to store all <word, index>, and then reverse, just find a match. ##### Corner case -If there is an empty string "", then it can be paired with any palindrome word, and it can be transformed back and forth according to the position to make 2 distinct indexes. -This has the logic of `if (reverseEnd.equals (" ")) {...}`. -Note: Although the two for loops that deal with beheading / tailing are repeating records based on empty string,   But because "" itself cannot be used as a starting point, overall will only be recorded once when paired with other palendrome. #### Method 2: Trie Still have to do that. --- ** 24. [Maximal Rectangle.java] (https://github.com/awangdev/LintCode/blob/master/Java/Maximal%20Rectangle.java) ** Level: Hard Tags: [Array, DP, Hash Table, Stack]        #### Method 1: monotonous stack Decomposed, it is actually 'Largest Rectangle in Histogram', but here you have to build your own model heights. The rectangle in a 2D array is also finally made with height * width. The clever thing is, treat each line as the bottom edge, and calculate the height of the bottom edge to the top: -If there is a value == 0 on the bottom edge, then it is counted as no height. -If value == 1 on the bottom edge, then add the above height to make a histogram If you look at specific examples, some rows seem to be calculated in vain, but there is no way. This is a search process, and the optimal solution will eventually be compared. #### Method 2: DP Coordinate DP? --- ** 25. [Longest Increasing Path in a Matrix.java] (https://github.com/awangdev/LintCode/blob/master/Java/Longest%20Increasing%20Path%20in%20a%20Matrix.java) ** Level : Hard Tags: [Coordinate DP, DFS, DP, Memoization, Topological Sort]        m x n matrix, find the longest increasing sequence length. Here, the default sequence is continuous. -Looping is not possible, so visit (x, y) can't go anymore. -Cannot walk in oblique direction, only walk up, down, left and right -Can't do according to coordinate DP, because the calculation order can go in 4 directions. -In the end, all nodes must be visited, so DFS search is more appropriate. #### DFS, Memoization -Simple version: longest path, only allow right / down direction: -`dp [x] [y] = Math.max (dp [prevUpX] [prevUpY], or dp [prevUpX] [prevUpY] + 1)`; and compare the other direction as well -This problem, just compare the direction from dfs result -DFS has too many double calculations; memoization (dp [] [], visited [] []) eliminates double calculations -initialize dp [x] [y] = 1, (x, y) counts itself as a cell in path -dfs (matrix, x, y): check 4 neighbors (nx, ny) of (x, y) each time, if they are increasing to (x, y), then consider and compare: -Maht.max (dp [x] [y], dp [nx] [ny] + 1); where dp [n] [ny] = dfs (matrix, nx, ny) -top level: O (mn), try to start from each (x, y) -O (m * n * k), where k is the longest path #### Topological sort Not done yet --- ** 26. [Coins in a Line III.java] (https://github.com/awangdev/LintCode/blob/master/Java/Coins%20in%20a%20Line%20III.java) ** Level: Hard Tags : [Array, DP, Game Theory, Interval DP, Memoization]        LeetCode: Predict the Winner Still 2 people take n coins, and coins can have different values. But this time the player can take from any side, but not restricted from one side. Will the first mover win? #### Memoization + Search -Like Coins in a Line II, MaxiMin's idea: Find the maximum of my disadvantages -`dp [i] [j] represents the sum of the values ​​that the player can take in the [i, j] interval` -Similarly, sum [i] [j] represents the sum of values ​​between [i] and [j] -Worst case for opponent, best case for first mover: -dp [i] [j] = sum [i] [j]-Math.min (dp [i] [j-1], dp [i + 1] [j]); -You need to search here, draw a tree to see how it is segmented according to before and after fetching. #### Game + Interval DP, Interval DP -Because it looks at the interval [i, j], it can be thought of as the interval DP -This method needs a review, and it is related to the inference of mathematical expressions: S (x) =-S (y) + m. Refer to the following formula for derivation. -dp [i] [j] indicates that from index (i) to index (j), the maximum value that the first player can get is different from the opponent's number. That is S (x). -One of S (x) = dp [i] [j] = a [i]-dp [i + 1] [j] -There are two cases where m is at the beginning and m is at the end: -dp [i] [j] = max {a [i]-dp [i + 1] [j], a [j]-dp [i] [j-1]} -len = 1, integral is values ​​[i] -Finally judge dp [0] [n]> = 0, the difference between the maximum number sum is greater than 0, and you win. -Time / space O (n ^ 2) ##### Formula Derivation -S (x) = X-Y, find the difference between the largest number and sum, where X and Y are the total score of player X and the total score of player Y. -For player X: If the maximum value of S (x) is greater than 0, you win; if the maximum value is less than 0, you must lose. -Player Y: S (y) to indicate the difference between the maximum number and sum for Y. S (y) = Y-X -According to S (x), if you take a number m from the number and X, that is X = m + Xwithout (m) -S (x) = m + Xwithout (m)-Y = m + (Xwithout (m)-Y). -If we simply remove m from the global, then S (y '') = Y-Xwithout (m) -Then calculate it: S (x) = m + (Xwithout (m)-Y) = m-(Y-Xwithout (m)) = m-S (y '') -In this question, when we model X and Y, they are actually dp [i] [j], and the difference is first-hand / last-hand. -Apply the formula, a certain S (x) = a [i]-dp [i + 1] [j], which is m = a [i], and S (y '') = dp [i + 1] [j] ##### Note -If you consider calculating the maximum value between the first hand [i, j], then two arrays may be needed, and finally used to compare the scores of the first hand and the opponent => then more dimensions are needed. -The number difference we consider here just happens to make people not need to calculate the total score of the first mover, very clever. -Trick: Using the difference formula, the derivation is a bit difficult to think of. ##### Interval Dynamic Programming -Find the properties within the [i, j] interval: dp [i] [j] The subscript indicates the interval range [i, j] -Sub-question: behead, tail, behead -loop should be based on the length of the interval -template: consider len = 1, len = 2; when setting i must be i <= n-len; when setting j, j = len + i-1; --- ** 27. [Burst Balloons.java] (https://github.com/awangdev/LintCode/blob/master/Java/Burst%20Balloons.java) ** Level: Hard Tags: [DP, Divide and Conquer, Interval DP, Memoization]        In a volleyball, each ball has a value, and each time you break one, you will score: left * middle * right. Find, how to tie, the maximum? TODO: Need more thoughts on why using dp [n + 2] [n + 2] for memoization, but dp [n] [n] for interval DP. #### Interval DP -Because the regularity of the array changes, it is difficult to find the 'first burst'. On the contrary, which one is the last burst? -The last burst becomes a wall: separate the two sides, consider separately, the principle of addition; finally add the middle. -dp [i] [j] represent max value on range [i, j) -Need to calculate dp [i] [j] incrementally, starting from range size == 3 ---> n -Use k to divide the range (i, j) and conquer each side. ##### Interval DP Three Axes: -Split in the middle -Cut off head or tail -Range as the basis of iteration ##### Print the calculation process -use pi [i] [j] and print recursively. -Print k, using pi [i] [j]: max value taken at k #### Memoization -In fact, it will be a DP that I think about afterwards -dp [i] [j] = max between balloons i ~ j. -Then which point to start the burst? Set to x. -For loop all points are taken as x, go to burst. -Each burst is cut into three parts: the left side can be recusive to find the maximum value of the remaining part on the left side + the middle 3 terms are multiplied + the right side is recursive to find the maximum value. -Note: This is Memoization, not pure DP -Because it is recursive, it is still a search, but memorize the requested value, saving processing --- ** 28. [K Edit Distance.java] (https://github.com/awangdev/LintCode/blob/master/Java/K%20Edit%20Distance.java) ** Level: Hard Tags: [DP, Double Sequence DP, Sequence DP, Trie)        Give a string of String, target string, int k. Find all the dates in the string array: change K times, can become target. #### Trie TODO #### Double Sequence DP -Follow distance for Edit Distance. -In fact, it is to change the function of minEditDistance and bring K for comparison. -The main logic is exactly the same as Edit Distance. -But LintCode 86% test case is timeout. -Time O (mnh), where h = words.length, if n ~ m, Time is almost O (n ^ 2), which is too slow. --- ** 29. [Paint House II.java] (https://github.com/awangdev/LintCode/blob/master/Java/Paint%20House%20II.java) ** Level: Hard Tags: [DP, Sequence DP , Status DP]        time: O (NK ^ 2): space: (NK) A row of n houses, each house can be painted in k colors, the price of each house is different, expressed by costs [] []. costs [0] [1] means that the house with index 0 is painted and color 1. Rule: two adjacent houses cannot be the same color Seek: the least cost #### DP -It's almost the same as Paint House I, but with more paint colors: k colors. -First consider simply using dp [i] to represent the minimum cost of the first i houses -But what color dp [i] and dp [i-1] index will affect each other, it is difficult to discuss, so add state: the sequence DP is added to the state to 2D. -Consider the last bit, and the previous i-1 is limited by the color of the i bit, so when considering min dp [i], there is another layer of iteration. -Do dp [i] [j]: # cost for the first i houses, so we must first pick the cost of the (i-1) house, then find out the cost of the (i-2) house -K colors => O (NK ^ 2) -If not optimized, it is almost the same code as Paint House I -Time O (NK ^ 2), space (NK) -Rolling array: reduce space to O (K) #### Note -The sequence type dp [i] represents the result of 'top i-1'. So dp is best set to int [n + 1] size. -However, the color is the state here, so it remains in j: [0 ~ k) -[[8]] This edge case. Can't run into for loop, so special handle. #### Optimization Solution -Time: O (NK) ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        Explanation ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        - ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---        ---                            ---        ---        ---              ---        ---        ---        ---        TODO ---
